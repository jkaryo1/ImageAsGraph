Jon Karyo, Calvin Knowlton, David Feldman, Derek Fischer
jkaryo1, cknowlt3, dfeldma9, dfisch11
--------------------------------------------//

Part I - Graph Implementation 

--------------------------------------------//

Part 1 was relatively easy as all we had to do was 
slightly alter the GraphAdjMatrix.java implementation
and make it use an  adjacency/incidence list. We chose 
to use a hashmap list that holds a vertex and a Linked List
of Edges incident to the vertex that are inserted in order. 
We originally used an array list to store our incident edges,
but thought that a linked list would be more efficient, 
especially so because we chose to store our edges ordered.
We all worked and tested each others' code so it is hard 
to say who exactly did what.

--------------------------------------------//

Part II - Minimally Weighted Spanning Trees

--------------------------------------------//

Part 2 was not that difficult but much worse than part 1. We had
a decent amount of trouble with our PQHeap and were banging our
heads against the wall until we realized that our issue was not
with our PQHeap but instead our PQHeapTest. Once we recreated our
JUnit test, we were able to push past our PQHeap issues. Also with
Kruskal's, we had a little trouble completely understanding the
use of the given Partition class, but once we were able to wrap
our heads around it, Kruskal's became rather trivial. 

--------------------------------------------//

Part III - Images as Graphs

--------------------------------------------//

                                       ___-------___
                                   _-~~             ~~-_
                                _-~                    /~-_
             /^\__/^\         /~  \                   /    \
           /|  O|| O|        /      \_______________/        \
          | |___||__|      /       /                \          \
          |          \    /      /                    \          \
          |   (_______) /______/                        \_________ \
          |         / /         \                      /            \
           \         \^\\         \                  /               \     /
             \         ||           \______________/      _-_       //\__//
               \       ||------_-~~-_ ------------- \ --/~   ~\    || __/
                 ~-----||====/~     |==================|       |/~~~~~
                  (_(__/  ./     /                    \_\      \.
                         (_(___/                         \_____)_)
                         
					"Your speed doesn't matter - Forward is forward."
             				-- Ancient Chinese Proverb

Part III was much more difficult and time consuming than part I and II combined, dare I say.
We were able to correctly split each image into their corresponding components. 
While our program does suffer at times when it comes to time complexity, all images 
do get processed. When implementing segmenter, we used our PQHeap and a new class called 
GraphPartition. GraphPartition utilized a HashMap of <Integer, MinMax> because we believed 
a HashMap would provide the fastest, most efficient access (a MinMax is a simple class we 
created on the fly). Despite the slowness when it comes to large images, the files write 
relatively quickly, so the slowest part is initializing the PQHeap.

1: What was awkward with respect to the original WGraph interface when using it to solve 
   part C? How would you have liked to change it?
   
   It seemed as though we were always taking things out of one graph and putting them into 
   a new graph with very small changes. We wish there were more direct graph functions and
   more explicit directions as to what we were supposed to do.
   
2: What k values worked for certain images you tested with? What challenges did you 
   encounter in part C in particular?
   
   When the images were small and very sharp around the edges, most k values seemed to 
   work well. Larger images seemed to need k values that were larger so as to maintain 
   edges.
   
3: Where is your solution the slowest and why? Could you have done things differently to 
   improve this?

   Our solution is slowest when initializing the PQHeap. We most likely could have 
   utilized a different backbone to the heap in order to make it more efficient.
   
   
Thanks Data Structures TAs!!!!

Love,

Dave, Derek, Alex, and Jack